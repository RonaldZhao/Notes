 ===============================================================================
|               注意：以下文档仅供参考，如有大神发现错误，望请指教                      |
|                                QQ：546496587                                  |
|              另外：建议大家不要轻易相信论坛中的帖子，尽量看相关书籍                    |
 ===============================================================================
《 Java核心技术卷1》笔记
2.1.3安装库源文件和文档：
  库源文件在JDK中以压缩文件src.zip的形式发布，解压步骤如下：
    进入jdk目录，建立一个名为src的子目录，进入src目录，在当前路径打开shell
    执行命令：jar xvf ../src.zip(Windows中执行jar xvf ..\src.zip)
  提示：src.zip中包含的是所有公共类库的源代码，更多源代码：http://jdk8.java.net
3.4.2常量
  在java中，常量用关键字final指示，例如：final double PI = 3.14;
  关键字final表示这个变量只能被赋值一次，一旦被赋值后就不能再更改了。习惯上常量名使用全大写。
  在Java中，如果需要定义一个类常量使用关键字static final设置一个类常量，如果在最前再加上public关键字，
  那么其他类的方法也可以使用这个常量。
3.5.3位运算
  ">>"和"<<"运算符将二进制位进行右移或左移操作。当需要建立位模式屏蔽某些位时，使用这两个运算符十分方便。
  ">>>"运算符将用0填充最高位，">>"运算符用符号位填充最高位。没有"<<<"运算符。
3.6.9构建字符串
  在jdk5.0中引入StringBuilder类。这个类的前身是StringBuffer，其效率有些低，但允许采用多线程的
  方式执行添加或删除字符的操作。如果所有字符在一个单线程中编辑(通常都是这样)，则应该用StringBuilder替代它。
3.7.1读取输入
  读取"标准输入流"System.in：
    要相通过控制台进行输入，首先需要构造一个Scanner对象，并与"标准输入流"System.in关联。
      Scanner in = new Scanner(System.in);
      现在，就可以使用Scanner类的各种方法实现输入操作了。例如：nextLine方法将输入一行。
      System.out.println("What is your name?");
      String name = in.nextLine();
      在这里，使用nextLine方法是因为考虑到输入行中可能含有空格。要想读取一个单词(以空白符作为分隔符)，就调用
      String firstName = in.next();
    最后，在程序的开头导入Scanner类所在的包java.util.*;
4.1.4类之间的关系
  在类之间，最常见的关系有：
    *依赖("uses-a")
    *聚合("has-a")
    *继承("is-a")
4.2.1对象与对象变量
  Date deadline = new Date();//有两个部分。new Date()构造了一个Date类型的对象，并且它的值是对新创建的对象的引用。
                             //这个引用存储在变量deadline中。
  Date deadline; //一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。
  局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化。
4.3.4构造器
  *构造器与类同名
  *每个类可以有一个以上的构造器
  *构造器可以有0个、1个或多个参数
  *构造器没有返回值
  *构造器总是伴随着new操作一起调用
  注意：不要在构造器中定义与实例域重名的局部变量。因为这些变量只能在构造器内部访问，屏蔽了实例域的同名变量。
4.3.5隐式参数与显式参数
  比如：number.raiseSalary(5);
  第一个参数称为隐式(implicit)参数，是出现再方法名前的类对象。第二个参数是位于方法名后面括号中的数值，这是一个显式(explicit)参数。
  在每一个方法中，关键字this表示隐式参数。
4.3.6封装的优点
  在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：
    *一个私有的数据域
    *一个公有的域访问器方法
    *一个公有的域更改器方法
  这样做比提供一个简单的公有数据域复杂些，但是却有如下明显的好处：
    *可以改变内部实现，除了该类的方法之外，不会影响其他代码。
    *更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。
  注意：不要编写返回引用可变对象的访问器方法。这样会破坏封装性。
       如果需要返回一个可变对象的引用，应该首先对它进行克隆(clone)。对象clone是指存放在另一个位置上的对象副本。
4.4.1静态域
  如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。
  例如：假定需要给每一个雇员赋予唯一的标识码。
    class Employee{
      private int id;
      private static int nextId;
    }
  现在，每个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。换句话说，如果有1000个Employee类id对象，
  则有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。即使一个雇员对象也没有，静态域nextId
  也存在。它属于类，而不属于任何独立的对象。
4.4.3静态方法
  静态方法是一种不能向对象实施操作的方法，所以不能在静态方法中访问实例域。但是，静态方法可以访问自身类中的静态域。
  建议：使用类名调用静态方法，而不是使用对象调用静态方法。
  在下面两种情况下使用静态方法：
    *一个方法不需要访问对象状态，其所需参数都是通过显式参数提供(例如：Math.pow)。
    *一个方法只需要访问类的静态域(例如：Employee.nextId)。
4.6.7初始化块(initialization block)
  在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。
  但是这种机制不是必需的，也不常见。通常直接将初始化代码放在构造器中。
4.7.4包作用域
  标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用；如果没有指定public或private，
  这个部分(类、方法 或变量)可以被同一个包中的所有方法访问。
4.8类路径
  javac编译器总是在当前的目录中查找文件，但java虚拟机仅在类路径中有"."目录的时候才查看当前目录。
  如果没有设置类路径，那也不会产生什么问题，默认的类路径包含"."目录。然而如果设置了类路径却忘记了包含"."目录，
  则程序仍然可以通过编译，但不能运行。
  注：一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。
4.10类的设计技巧
  1）一定要保证数据私有。
    这是最重要的；绝对不要破坏封装性。有时候，需要编写一个访问器方法或更改器方法，但是最好还是保持实例域的私有性。
    很多惨痛的经验说明，数据的表示形式很可能会改变，但它们的使用方式却不会经常发生变化。当数据保持私有时，它们的
    表示形式的变化不会对类的使用者产生影响，即使出现bug也易于检测 。
  2）一定要对数据初始化。
    Java不对局部变量进行初始化，但是会对对象的实例域进行初始化。最好不要依赖与系统的默认值，而是应该显式地初始化所有的数据。
    具体的初始化方式可以是提供默认值，也可以是在所有构造器中设置默认值。
  3）不要在类中使用过多的基本类型。
  4）不是所有的域都需要独立的域访问器和域更改器。
  5）将职责过多的类进行分解。
  6）类名和方法名要能够体现它们的职责。
5.多态
  *一个对象变量可以指示多种实际类型的现象被称为多态(polymorphism)。在运行时能够自动地选择调用哪个方法
  的现象称为动态绑定(dynamic binding).
  *"is-a"规则的另一种表述法是置换法则。它表名程序中出现超类对象的任何地方都可以用子类对象置换。
  *不能将一个超类的引用赋给子类的变量。
5.1.3动态绑定
  在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要
  声明为public。
================================================================================
自动类型转换：当容量小的数据类型与容量大的数据类型做运算时，容量小的会自动转换为容量大的数据类型
  char,byte,short===>int===>long===>float===>double
================================================================================
Java 8新特性：lambda表达式

Java 8终于引进了lambda表达式，这标志着Java往函数式编程又迈进了一小步。

在Java 8以前的代码中，为了实现带一个方法的接口，往往需要定义一个匿名类并复写接口方法，代码显得
很臃肿。比如常见的Comparator接口：

String[] oldWay = "Improving code with Lambda expressions in Java 8".split(" ");
Arrays.sort(oldWay, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        // 忽略大小写排序:
        return s1.toLowerCase().compareTo(s2.toLowerCase());
    }
});
System.out.println(String.join(", ", oldWay));

对于只有一个方法的接口，在Java 8中，现在可以把它视为一个函数，用lambda表示式简化如下：

String[] newWay = "Improving code with Lambda expressions in Java 8".split(" ");
Arrays.sort(newWay, (s1, s2) -> {
    return s1.toLowerCase().compareTo(s2.toLowerCase());
});
System.out.println(String.join(", ", newWay));

Java 8没有引入新的关键字lambda，而是用()->{}这个奇怪的符号表示lambda函数。函数类型不需要申
明，可以由接口的方法签名自动推导出来，对于上面的lambda函数：

(s1, s2) -> {
    return s1.toLowerCase().compareTo(s2.toLowerCase());
});

参数由Comparator<String>自动推导出String类型，返回值也必须符合接口的方法签名。

实际上，lambda表达式最终也被编译为一个实现类，不过语法上做了简化。

对于Java自带的标准库里的大量单一方法接口，很多都已经标记为@FunctionalInterface，表明该接口
可以作为函数使用。

以Runnable接口为例，很多时候干活的代码还没有定义class的代码多，现在可以用lambda实现：

public static void main(String[] args) {
    // old way:
    Runnable oldRunnable = new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ": Old Runnable");
        }
    };
    Runnable newRunnable = () -> {
        System.out.println(Thread.currentThread().getName() + ": New Lambda Runnable");
    };
    new Thread(oldRunnable).start();
    new Thread(newRunnable).start();
}

在未来的Java代码中，会出现越来越多的()->{}表达式。
文章来源：
http://www.liaoxuefeng.com/article/001411306573093ce6ebcdd67624db98acedb2a905c8ea4000
================================================================================
多态性的体现：
  1.方法的重载和重写
  2.对象的多态性
  3.对象的多态性：
    向上转型：程序自动完成
      父类 父类对象 = 子类实例
    向下转型：强制类型转换
      子类 子类对象 = (子类)父类实例
================================================================================
泛型：
  1.泛型是在jdk1.5之后新增的功能。泛型（Generic）
  2.泛型可以解决数据类型的安全性问题，主要的原理是，在类声明的时候通过一个
    标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。
  3.格式：访问权限 class 类名称<泛型、泛型...> {属性 方法}
  4.对象的创建：类名称<具体类型> 对象名称 = new 类名称<具体类型>();
  5.通配符：？表示
  6.接口中应用泛型
  7.泛型方法：其中可以定义泛型参数，此时，参数的类型就是传入数据类型
      格式：访问权限 <泛型标识> 泛型标识 方法名称([泛型标识 参数名称])
      使用：直接在参数中传递任何类型的数据
  8.泛型数组：在使用泛型方法的时候，也可以传递或返回一个泛型数组
================================================================================
Java中的IO操作:
  1.Java IO简介
    IO也写作“I/O”，也可理解为In和Out，即输入与输出。
    所以，IO体系的基本功能就是：读和写。
    IO流：
      作用：读写设备上的数据，硬盘文件、内存、键盘、网络...
      根据数据的走向，可分为：输入流、输出流
      根据处理的数据类型，可分为：字节流、字符流。
        字节流：可以处理所有类型的数据。在Java中对应的类都以”Stream“结尾。
        字符流：只能处理纯文本数据。在Java中对应的类都以”Reader“或”Writer”结尾。
  2.字符、字节与编码：
    1.字节：是通过网络传输信息或在硬盘或内存中存储信息的单位，是计算机信息技术用于计量存储容量
      和传输容量的一种计量单位。
    2.字符(char)：是人们使用的记号，是抽象意义上的一个符号。
    3.字符集(charset)：也称作编码。
    4.ANSI
    5.Unicode
  3.使用字节流读写数据
    FileInputStream fis = new FileInputStream("test.txt");fis.close();
    FileOutputStream fos = new FileOutputStream("test.txt");fos.close();
  4.使用带缓冲的字节流读写数据
    带有缓冲的字节流的读写速度要比不带缓冲的快很多。
  5.使用字符流读写数据
  6.使用带有缓冲的字符流读写数据
  7.FileReader与FileWriter
  8.RandomAccessFile随机文件读写
  9.使用Apache IO库操作IO与文件
===============================================================================
Java多线程编程:
  1.线程与进程
    *线程：程序中单独顺序的控制流
      线程本身依靠程序运行；
      线程是程序中的顺序控制流，只能使用分配给程序的资源和环境；
    *进程：执行中的程序
      一个进程可以包含一个或多个线程，但至少要包含一个；
    *单线程：程序中只存在一个线程，实际上主方法就是一个主线程；
    *多线程：一个程序中运行多个任务；目的是更好的利用CPU资源；
  2.线程的实现
    *在Java中，线程的实现有两种：
      1.继承Thread类
        *Thread类：定义在java.lang包中，继承Thread类必须重写run()方法；
      2.实现Runnable接口
    *线程的启动是通过start()方法，而不是run()方法；
  3.线程的状态
    *线程也有固定的操作状态：
      1.创建状态：准备好了一个多线程的对象
      2.就绪状态：调用了start()方法，等待CPU进行调度
      3.运行状态：执行run()方法
      4.阻塞状态：暂时停止执行，可能将资源交给其他线程使用
      5.终止状态（死亡状态）：线程销毁
  4.线程的常用方法
    1.取得线程名称：getName()
    2.取得当前线程对象:currentThread()
    3.判断线程是否启动:isAlive()
    4.线程的强行运行:join()
    5.线程的休眠:sleep()
    6.线程的礼让:yield()
  5.线程的优先级
    1.优先级顺序设置：
      1-MIN_PRIORITY
      10-MAX_PRIORITY
      5-NORM_PRIORITY
      什么都不设置默认值是5
  6.同步与死锁
    1.同步代码块：在代码块上加上"synchronized"关键字，则此代码块就称为同步代码块
    2.同步代码块格式：
      synchronized(同步对象){
        需要同步的代码块;
      }
    3.同步方法：除了代码块可以同步，方法也可以
    4.方法同步格式：
      synchronized 访问修饰符(可选) void 方法名称(){}
    5.需要使用同步的情况：需要资源共享的环境
    6.死锁：需求冲突
  7.线程的生命周期
================================================================================
Java 反射机制：
1.反射机制概述：
  1.反射机制背景概述：
    1）Reflection也就是反射，是Java被视为动态（或准动态）语言的一个关键性质；
    2）反射机制指的是程序在运行时能够获取任何类的内部所有信息；
  2.反射机制的实现功能概述：
    1）只要给定类的全名，即可通过反射获取类的所有信息；
    2）反射可以在程序运行时获取任意一个对象所属的类对象；
    3）在运行时可以获取到类中所有属性对象，并对其操作（包括私有属性）；
    4）在运行时可以获取到类中、父类中所有方法，并调用；
    5）目前主流的应用框架如Struts2、Hibernate、Spring、SpringMVC等框架的核心全部是利用
      Java的反射机制来实现的。
================================================================================
Java中的XML操作：
  1.XML数据格式简介
  XML，即可扩展编辑语言(Extensible Markup Language)，标准通用标记语言的子集，一种用于标记
  电子文件使其具有结构性的标记语言。它可以用来标记数据、定义数据类型，是一种允许用户对子集的标记
  语言进行定义的源语言。它非常适合万维网传输，提供同一的方法来描述和交换应用程序或供应商的结构化
  数据。
    *XML是一种标记语言，很类似于HTML
    *XML的设计宗旨是传输数据，而非显示数据
    *XML标签没有被预定义，需要用户自行定义
    *XML被设计为具有自我描述性
    *XML是W3C的推荐标准
  XML与HTML：
    XML和HTML为不同的目的而设计：
      *XML被设计为传输和存储数据，其焦点是数据的内容
      *HTML被设计为显示数据，其焦点是数据的外观
  XML的特点：
    *XML仅仅是纯文本
    *XML没有预定义的标签
  XML的语法规则：
    *标签对大小写敏感
    *所有标签必须有关闭标签
    *必须正确嵌套
    *必须有根元素
    *属性值必须加引号
    *空格会被保留
  2.使用Java读取XML数据
  3.使用Java创建XML数据
  4.使用Dom4j操作XML数据
================================================================================
Java中的JSON操作：
JSON简介：
  JSON：JavaScript对象表示法(JavaScript Object Notation)
  是存储和交换信息的语法
    *是轻量级的文本数据交换格式
    *独立于语言和平台
    *具有自我描述性，更易理解
  JSON与XML：
    *比XML更小、更快、更易理解
    *没有结束标签
    *读写速度更快
    *使用数组
    *不适用保留字
  JSON语法是JavaScript对象表示法的子集
    *数据在 名称/值 对中
    *数据由逗号分隔
    *花括号保存对象
    *方括号保存数组
  JSON值可以是：
    *数字(整数或浮点数)
    *字符串(在双引号中)
    *逻辑值(true或false)
    *数组(在方括号中)
      数组可以包含多个对象
        {
          "employees":[
            {"FirstName":"John","lastName":"Doe"},
            {"FirstName":"Anna","lastName":"Smith"},
            {"FirstName":"Peter","lastName":"Jones"}
          ]
        }
    *对象(在花括号中)
      对象可以包含多个 名称/值 对
        {"FirstName":"John","lastName":"Doe"}
    *null
================================================================================
Java的时间日期：
  Date类（不推荐）
  Calendar类
  DateFormat类
  Long
  String
将Date类型转换为String类型：
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
  sdf.format(date);
将String类型转换为Date类型：
  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
  sdf.parse("2015-06-01");
将Date类型转换为Calendar类型：
  c1.setTime(date);
将Calendar类型转换为Date类型：
  c1.getTime();
================================================================================
StringBuilder:
  1.是一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线
    程使用的时候，建议优先考虑该类，速度要比StringBuffer快很多。
  2.但是如果涉及到多线程和线程安全方面，建议使用StringBuffer。
================================================================================
String与StringBuffer的区别：
  简单地说，就是一个变量和常量的关系。StringBuffer对象的内容可以修改；而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。

  StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。
  所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。

  String:在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，
  所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。

  StringBuffer:StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。
  这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符 到 一个已经存在的字符串后面有效率得多。
  因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，
  这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。
